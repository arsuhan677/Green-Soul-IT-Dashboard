import { useState, useEffect } from 'react';
import { useNavigate } from 'react-router-dom';
import { supabase } from '@/integrations/supabase/client';
import { useAuth } from '@/contexts/AuthContext';
import { useToast } from '@/hooks/use-toast';
import { isValidUUID } from '@/lib/validation';
import { logActivity } from '@/lib/activityLogger';
import type { Json } from '@/integrations/supabase/types';

export interface QuotationItem {
  title: string;
  description: string;
  qty: number;
  price: number;
  total: number;
}

export interface Quotation {
  id: string;
  quote_number: string;
  client_id: string | null;
  client_name: string | null;
  issue_date: string;
  valid_until: string | null;
  items: QuotationItem[];
  subtotal: number;
  discount: number;
  tax: number;
  grand_total: number;
  status: string;
  note: string | null;
  created_by: string;
  created_by_name: string | null;
  is_deleted: boolean;
  deleted_at: string | null;
  created_at: string;
  updated_at: string;
}

export interface QuotationInput {
  client_id: string;
  client_name?: string;
  issue_date: string;
  valid_until?: string;
  items: QuotationItem[];
  discount?: number;
  tax?: number;
  note?: string;
  status?: string;
}

// Helper to parse items from JSONB
const parseItems = (items: Json): QuotationItem[] => {
  if (!items || !Array.isArray(items)) return [];
  return items.map(item => {
    if (typeof item === 'object' && item !== null && !Array.isArray(item)) {
      const obj = item as Record<string, Json>;
      return {
        title: String(obj.title || ''),
        description: String(obj.description || ''),
        qty: Number(obj.qty || 1),
        price: Number(obj.price || 0),
        total: Number(obj.total || 0)
      };
    }
    return { title: '', description: '', qty: 1, price: 0, total: 0 };
  });
};

// Helper to convert items to JSON
const itemsToJson = (items: QuotationItem[]): Json => {
  return items.map(item => ({
    title: item.title,
    description: item.description,
    qty: item.qty,
    price: item.price,
    total: item.total
  })) as Json;
};

export function useQuotations() {
  const { user, profile, isAdmin, isAuthenticated, refreshSession } = useAuth();
  const { toast } = useToast();
  const [quotations, setQuotations] = useState<Quotation[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const navigate = useNavigate();

  // Fetch quotations
  const fetchQuotations = async () => {
    if (!user) return;

    try {
      setLoading(true);
      const { data, error: fetchError } = await supabase
        .from('quotations')
        .select('*')
        .eq('is_deleted', false)
        .order('created_at', { ascending: false });

      if (fetchError) throw fetchError;

      const parsed: Quotation[] = (data || []).map(q => ({
        ...q,
        items: parseItems(q.items as Json)
      }));

      setQuotations(parsed);
      setError(null);
    } catch (err: any) {
      setError(err.message);
      console.error('Error fetching quotations:', err);
    } finally {
      setLoading(false);
    }
  };

  // Add quotation - quote_number is auto-generated by DB
  const addQuotation = async (input: QuotationInput): Promise<boolean> => {
    if (!user) return false;

    if (!isValidUUID(input.client_id)) {
      toast({
        title: "ত্রুটি!",
        description: "ভুল ক্লায়েন্ট আইডি পাঠানো হয়েছে।",
        variant: "destructive",
      });
      return false;
    }

    try {
      const subtotal = input.items.reduce((sum, item) => sum + item.total, 0);
      const grandTotal = subtotal - (input.discount || 0) + (subtotal * (input.tax || 0) / 100);

      // Do NOT send quote_number - it's auto-generated by DB default
      const { data: insertedData, error: insertError } = await supabase
        .from('quotations')
        .insert({
          client_id: input.client_id,
          client_name: input.client_name || null,
          issue_date: input.issue_date,
          valid_until: input.valid_until || null,
          items: itemsToJson(input.items),
          subtotal,
          discount: input.discount || 0,
          tax: input.tax || 0,
          grand_total: grandTotal,
          status: input.status || 'খসড়া',
          note: input.note || null,
          created_by: user.id,
          created_by_name: profile?.name || 'অজানা ব্যবহারকারী',
          is_deleted: false,
        })
        .select('quote_number')
        .single();

      if (insertError) throw insertError;

      const quoteNumber = insertedData?.quote_number || 'নতুন কোটেশন';

      toast({
        title: "সফল!",
        description: `কোটেশন ${quoteNumber} সফলভাবে তৈরি হয়েছে`,
      });

      await logActivity({
        userId: user.id,
        userName: profile?.name || 'অজানা ব্যবহারকারী',
        action: 'create',
        module: 'invoices',
        recordTitle: quoteNumber,
        details: `নতুন কোটেশন তৈরি হয়েছে: ${quoteNumber}`,
      });

      await fetchQuotations();
      return true;
    } catch (err: any) {
      console.error('Quotation creation error:', err);
      toast({
        title: "ত্রুটি!",
        description: err.message || "কোটেশন তৈরি করতে সমস্যা হয়েছে",
        variant: "destructive",
      });
      return false;
    }
  };

  // Update quotation
  const updateQuotation = async (quoteId: string, input: Partial<QuotationInput>): Promise<boolean> => {
    if (!user) return false;

    if (!isValidUUID(quoteId)) {
      toast({
        title: "ত্রুটি!",
        description: "ভুল কোটেশন আইডি পাঠানো হয়েছে।",
        variant: "destructive",
      });
      return false;
    }

    try {
      const updateData: Record<string, any> = {};

      if (input.client_id) updateData.client_id = input.client_id;
      if (input.client_name !== undefined) updateData.client_name = input.client_name;
      if (input.issue_date) updateData.issue_date = input.issue_date;
      if (input.valid_until !== undefined) updateData.valid_until = input.valid_until;
      if (input.status) updateData.status = input.status;
      if (input.note !== undefined) updateData.note = input.note;
      if (input.discount !== undefined) updateData.discount = input.discount;
      if (input.tax !== undefined) updateData.tax = input.tax;

      if (input.items) {
        updateData.items = itemsToJson(input.items);
        const subtotal = input.items.reduce((sum, item) => sum + item.total, 0);
        const discount = input.discount ?? 0;
        const tax = input.tax ?? 0;
        updateData.subtotal = subtotal;
        updateData.grand_total = subtotal - discount + (subtotal * tax / 100);
      }

      const { error: updateError } = await supabase
        .from('quotations')
        .update(updateData)
        .eq('id', quoteId);

      if (updateError) throw updateError;

      toast({
        title: "সফল!",
        description: "কোটেশন সফলভাবে আপডেট হয়েছে",
      });

      await fetchQuotations();
      return true;
    } catch (err: any) {
      toast({
        title: "ত্রুটি!",
        description: err.message || "আপডেট করতে সমস্যা হয়েছে",
        variant: "destructive",
      });
      return false;
    }
  };

  // Hard delete quotation (admin only)
  const deleteQuotation = async (quoteId: string): Promise<boolean> => {
    // Check authentication first
    if (!isAuthenticated() || !user) {
      toast({
        title: "সেশন শেষ!",
        description: "অনুগ্রহ করে আবার লগইন করুন",
        variant: "destructive",
      });
      navigate('/auth');
      return false;
    }

    if (!isValidUUID(quoteId)) {
      toast({
        title: "ত্রুটি!",
        description: "ভুল কোটেশন আইডি পাঠানো হয়েছে।",
        variant: "destructive",
      });
      return false;
    }

    try {
      // Refresh session to ensure valid token
      const refreshedSession = await refreshSession();
      if (!refreshedSession) {
        toast({
          title: "সেশন শেষ!",
          description: "অনুগ্রহ করে আবার লগইন করুন",
          variant: "destructive",
        });
        navigate('/auth');
        return false;
      }

      // Check admin status directly from database
      const { data: roleData, error: roleError } = await supabase
        .from('user_roles')
        .select('role')
        .eq('user_id', user.id)
        .eq('role', 'admin')
        .maybeSingle();

      if (roleError) {
        console.error('Role check error:', roleError);
      }

      if (!roleData) {
        toast({
          title: "অনুমতি নেই!",
          description: "শুধুমাত্র অ্যাডমিন কোটেশন মুছতে পারেন",
          variant: "destructive",
        });
        return false;
      }

      const quotation = quotations.find(q => q.id === quoteId);

      // Hard delete - permanently remove from database
      const { error: deleteError } = await supabase
        .from('quotations')
        .delete()
        .eq('id', quoteId);

      if (deleteError) {
        console.error('Quotation delete error details:', {
          code: deleteError.code,
          message: deleteError.message,
          details: deleteError.details,
          hint: deleteError.hint
        });
        throw deleteError;
      }

      await logActivity({
        userId: user.id,
        userName: profile?.name || 'অজানা ব্যবহারকারী',
        action: 'delete',
        module: 'invoices',
        recordId: quoteId,
        recordTitle: quotation?.quote_number,
        details: `কোটেশন স্থায়ীভাবে মুছে ফেলা হয়েছে: ${quotation?.quote_number || 'অজানা'}`,
      });

      // Refetch list after success
      await fetchQuotations();

      toast({
        title: "সফলভাবে মুছে ফেলা হয়েছে",
        description: "কোটেশন স্থায়ীভাবে মুছে ফেলা হয়েছে",
      });

      return true;
    } catch (err: any) {
      console.error('Quotation delete error:', err);
      
      if (err.code === '42501' || err.message?.includes('row-level security')) {
        toast({
          title: "RLS ত্রুটি!",
          description: `ডাটাবেজ অনুমতি সমস্যা: ${err.message}`,
          variant: "destructive",
        });
      } else {
        toast({
          title: "ত্রুটি!",
          description: err.message || "মুছে ফেলতে সমস্যা হয়েছে",
          variant: "destructive",
        });
      }
      return false;
    }
  };

  // Update status
  const updateStatus = async (quoteId: string, status: string): Promise<boolean> => {
    return updateQuotation(quoteId, { status });
  };

  useEffect(() => {
    fetchQuotations();
  }, [user]);

  return {
    quotations,
    loading,
    error,
    fetchQuotations,
    addQuotation,
    updateQuotation,
    deleteQuotation,
    updateStatus,
  };
}
